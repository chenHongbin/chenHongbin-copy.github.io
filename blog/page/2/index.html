
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Robert_Chen</title>
  <meta name="author" content="陈宏彬">

  
  <meta name="description" content="闲言 又到了周五，一周就这样灰溜溜的过去了，想着即将到来的周末还是挺激动的，虽然周日被公司活动无情的占用了，虽然得到晚上9点半后才能回来，虽然。。。。。。 这是我的第三篇博客文章，到目前为止感觉还是挺不错的，挺有冲动写文章的，但是，总是苦于不知道写什么。建这个博客的初衷是为了记录自己的生活、 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://chenHongbin.github.io/blog/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Robert_Chen" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Robert_Chen</a></h1>
  
    <h2>既往不念，未来不迎，当下不杂</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:chenHongbin.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/16/view-layexie-zuo-wen-zhang-xue-xi-bi-ji/">View-Laye协作的学习笔记</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-16T07:31:38+08:00" pubdate data-updated="true">May 16<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>闲言</h2>

<p>又到了周五，一周就这样灰溜溜的过去了，想着即将到来的周末还是挺激动的，虽然周日被公司活动无情的占用了，虽然得到晚上9点半后才能回来，虽然。。。。。。</p>

<p>这是我的第三篇博客文章，到目前为止感觉还是挺不错的，挺有冲动写文章的，但是，总是苦于不知道写什么。建这个博客的初衷是为了记录自己的生活、工作和学习。曾经志向远大，1、每读完一本书，就在这上面写一篇读书笔记（今年到现在为了读了十多本，还没写过一篇）2、每看到一篇好的英语博客，都把它翻译到这里来（medium.com已经收藏了一堆的文章、RSS里也藏了一堆、Pocket里也有一堆） 3、每学习新的技术知识就这里写几篇总结文章（最近用Mantle和AF用的巨爽，但是也是没有什么行动）。所以，问题其实也并不是不知道写什么，而是自己略懒，同时，时间管理上还是存在很多问题。但是无论如何，现在已经开始了也为时不晚，就像那天姐夫发给我的正能量说的</p>

<pre><code>人生永远都可以随时开始，关键在于你敢不敢果断的转身；任何事都可能有好结果，重要的是你有没有承受光明到来之前的黑暗
</code></pre>

<p>还有一件事就是，决定以后无论什么文章，都要在最前面加上这个“闲言”栏目，先扯扯人生、谈谈理想、抒发抒发感慨，再板砖（感觉有点像那些饱读成功学书籍的人，在每次出门前都要对着镜子里的自己高喊“我一定可以成功的！我是最棒的！加油！加油！”）。</p>

<h2>正文</h2>

<p>这是一篇学习笔记，来自于这两天学习<a href="http://objccn.io/issue-12-4/">View-Layer 协作</a>这篇文章，这篇是微博上的大神<a href="http://weibo.com/onevcat">@onevcat</a>译自<a href="http://www.objc.io/">objc.io</a>的<a href="http://www.objc.io/issue-12/view-layer-synergy.html">View-Layer Synergy</a>。看完这篇文章后，发现自己的两点问题，</p>

<pre><code> 1、在学习时，动手实践的精神和思考问题的深度还远远不够，往往总是浅尝则止
 2、在学习官方文档的时候粗心大意，细节都被我忽略了，当然，这个跟本人的英语水平也有一定必然的   
    联系，所以，还是多背单词、少睡觉、多查字典、少偷懒。
</code></pre>

<h2>View和Layer的关系</h2>

<p>1、所有的View都是由一个底层的Layer来驱动的，View其实直接从Layer对象中获取了绝大多数他所需要的数据，因此，对于Layer的修改将会自动映射到所对应的View上，所以，你可以通过修改Layer或者View的属性来达到相同的效果；</p>

<p>2、存在单据的Layer，如<a href="https://developer.apple.com/library/mac/documentation/AVFoundation/Reference/AVCaptureVideoPreviewLayer_Class/Reference/Reference.html">AVCaptureVideoPreviewLayer</a> 和 <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/Reference/Reference.html">CAShapeLayer</a>，不需要附加到View上就可以在屏幕上显示内容；</p>

<p>3、以上两种情况，都是Layer在起决定作用，但是附加到View上的Layer和单独的Layer在行为上还是稍有不同的。改变一个单独的Layer的任何animatable属性，都会触发一个从旧值过度到新值的默认简单动画，然后如果改变一个View中的Layer的同一个属性，它只会从这一帧直接跳到下一帧，因为当Layer附件到View上时，默认的隐式动画的Layer行为就不起作用了；</p>

<blockquote><p>If you want to use Core Animation classes to initiate animations, you must issue all of your Core Animation calls from inside a view-based animation block. The UIView class disables layer animations by default but reenables them inside animation blocks.</p></blockquote>

<h2>Layer是如何执行动画的？CAAction</h2>

<p>4、无论何时一个可动画的Layer属性改变时，Layer都会寻找并运行合适的‘action’来实行这个改变，在Core Animation的专业术语中把这样的动画统称为动作（<a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CAAction_protocol/Introduction/Introduction.html">CAAction</a>）,<a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CAAction_protocol/Introduction/Introduction.html">CAAction</a>,从技术上来说，这是一个接口，并可以用来做各种事情。但是实际中，某种程度上你可以只把它理解为用来处理动画。</p>

<p>5、在改变一个Layer的属性，并执行一个动作(<a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CAAction_protocol/Introduction/Introduction.html">CAAction</a>)之前，Layer需要找到相应的动作对象(<a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CAAction_protocol/Introduction/Introduction.html">CAAction</a>)。当一个恰当的动作事件发生在Layer时，Layer对象调用 <code>actionForKey:</code> 方法来寻找相应的动作对象(<a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CAAction_protocol/Introduction/Introduction.html">CAAction</a>)。我们可以在某些节点提供我们需要的特定动作(<a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CAAction_protocol/Introduction/Introduction.html">CAAction</a>)。</p>

<p>6、Layer将像文档中所写的那样去寻找(<a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CAAction_protocol/Introduction/Introduction.html">CAAction</a>)，整个过程分为五部，第一步为Layer通过向他的delegate发送<code>actionForLayer:forKey:</code> 消息来询问提供一个对象属性变化的<a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CAAction_protocol/Introduction/Introduction.html">CAAction</a>, delegate可以通过返回以下三者之一来进行响应：</p>

<pre><code>(1)、返回一个动作对象，这种情况下Layer将使用这个动作。
(2)、返回一个nil, 这样layer会到其它地方继续寻找
(3)、返回一个NSNull对象，告诉layer这里不需要执行一个动作，搜索也会就此结束
</code></pre>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/ReactingtoLayerChanges/ReactingtoLayerChanges.html#//apple_ref/doc/uid/TP40004514-CH7-SW1">Core Animation文档中如此描述:</a></p>

<blockquote><p>Core Animation looks for action objects in the following order:</p>

<p>1、If the layer has a delegate and that delegate implements the actionForLayer:forKey: method, the layer calls that method. The delegate must do one of the following:</p>

<p>·Return the action object for the given key.</p>

<p>·Return nil if it does not handle the action, in which case the search continues.</p>

<p>·Return the NSNull object, in which case the search ends immediately.</p>

<p>2、The layer looks for the given key in the layer’s actions dictionary.</p>

<p>3、The layer looks in the style dictionary for an actions dictionary that contains the key. (In other word, the style dictionary contains an actions key whose value is also a dictionary. The layer looks for the given key in this second dictionary.)</p>

<p>4、The layer calls its defaultActionForKey: class method.</p>

<p>5、The layer performs the implicit action (if any) defined by Core Animation.</p></blockquote>

<h2>UIView的动画Block解析</h2>

<p>7、当Layer在背后支持一个View的时候，View就是它的delegate。在iOS中，如果Layer与一个UIView对象关联时，view就是它的delegate。</p>

<pre><code>“在 iOS 中，如果 layer 与一个 UIView 对象关联时，这个属性必须被设置为持有这个 layer 的那个 view”
</code></pre>

<p>8、属性改变时 layer 会向 view 请求一个动作，而一般情况下 view 将返回一个 NSNull，只有当属性改变发生在动画 block 中时，view 才会返回实际的动作。</p>

<p>9、对于 view 中的 layer 来说，对动作的搜索只会到第一步为止，即返回一个默认动画或者NSNull。</p>

<p>10、插播：值得注意的是打印出的 NSNull 是带着一对尖括号的 (&ldquo;<null>&rdquo;)，这和其他对象一样，而打印 nil 的时候我们得到的是普通括号((null))。</p>

<p>11、当属性在动画block中改变时，view将向layer返回一个基本的动画，然后动画通过通常的addAnimation:forkey:方法被添加到layer中，就像显示地添加动画那样。</p>

<p>输出值：</p>

<pre><code>&lt;CABasicAnimation:0x8c73680; 
  delegate = &lt;UIViewAnimationState: 0x8e91fa0&gt;;
  fillMode = both; 
  timingFunction = easeInEaseOut; 
  duration = 0.3; 
  fromValue = NSPoint: {5, 5}; 
  keyPath = position&gt;
</code></pre>

<p>12、当动画刚被添加到layer时，属性的新值还没有被改变。在构建动画时，只有fromValue被显示地指定了。在<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html">CABasicAnimation的文档</a>中可以看到具体的关于<code>fromeValue</code>、<code>toValue</code>、<code>byValue</code>的值的问题：</p>

<blockquote><p>The fromValue, byValue and toValue properties define the values being interpolated between. All are optional, and no  more than two should be non-nil. The object type should match the type of the property being animated.</p>

<p>The interpolation values are used as follows:</p>

<p>·Both fromValue and toValue are non-nil. Interpolates between fromValue and toValue.</p>

<p>·fromValue and byValue are non-nil. Interpolates between fromValue and (fromValue + byValue).</p>

<p>·byValue and toValue are non-nil. Interpolates between (toValue &ndash; byValue) and toValue.</p>

<p>·fromValue is non-nil. Interpolates between fromValue and the current presentation value of the property.</p>

<p>·toValue is non-nil. Interpolates between the current value of keyPath in the target layer’s presentation layer and toValue.</p>

<p>·byValue is non-nil. Interpolates between the current value of keyPath in the target layer’s presentation layer and that value plus byValue.</p>

<p>·All properties are nil. Interpolates between the previous value of keyPath in the target layer’s presentation layer and the current value of keyPath in the target layer’s presentation layer.</p></blockquote>

<p>13、关于上面输出的delegate，是一个UIViewAnimationState的私有类对象，主要用来维护动画的一些状态，如持续时间、延时、重复次数等等。还负责对一个栈做push和pop,这是为了在多个动画block嵌套时，能够获取正确的动画状态 可以看看<a href="https://github.com/rpetrich/iphoneheaders/blob/master/UIKit/UIViewAnimationState.h">dump出来的头文件</a></p>

<p>14、UIViewAnimationState对象作为UIView返回给Layer的动画的delegate实现了<code>animationDidStart:</code> 和 <code>animationDidStop:finished:</code>方法，并将信息传给了自己的delegate, 这个delegate是一个私有类：UIViewAnimationBlockDelegate，<a href="https://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/UIKit.framework/UIViewAnimationBlockDelegate.h">dump出来的头文件</a>，这是一个很小的类，只负责一件事情：响应动画的delegate回调并且执行相应的block。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/guan-yu-calayerde-positionhe-anchorpointde-%5B%3F%5D-dian-li-jie/">关于CALayer的position和anchorPoint的一点理解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T12:13:48+08:00" pubdate data-updated="true">May 11<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>闲言</h2>

<p>翻看记录，发现自从3月底搭建完这个blog写了第一篇文章后，就再也没有写过任何东西了，只能在心底强烈的鄙视自己一番。鉴于最近在新项目中学到不少东西，同时，发现很多东西没有掌握，所以计划在接下来的一段时间内，好好学习，偶尔记录，希望能多写点东西。</p>

<h2>关于CALayer</h2>

<p>在Core Animation中最基本也是最重要的内容就是CALayer，每个UIView都有一个CALayer对象。CALayer在很多方面与UIView非常相似。它拥有位置、大小、变形和内容。但是CALayer并不是用来替代UIView对象的，相反，它是和UIView一起协作的。UIView是一个很重量级的对象，它管理绘制与事件处理（尤其是触摸事件），CALayer则完全关乎绘制，UIView依靠CALayer来管理绘制，通过这样的分工两者就能协作的更好。</p>

<h2>CALayer的几何属性</h2>

<p>就像前面说的，CALayer拥有自己的位置（position）、大小(bounds,frame)、变形(transform)和内容(content)，同时，它还拥有一个UIView所没有的属性anchorPoint。其中position、bounds、frame是基于点坐标系的（point-based coordinate systems），而anchorPoint是基于单元坐标系的（unit coordinate systems），即X坐标和Y坐标的取值在0-1之间。bounds和frame的意思比较好理解，farme为CALayer在其父层（superLayer）上的位置和大小，而bounds则是可以简单理解为CALayer的大小，其X坐标和Y坐标为0。剩下的position和anchorPoint则是最容易让人困惑的。</p>

<h2>position</h2>

<p>在CALayer.h文件中我们可以看到:</p>

<pre><code>/* The position in the superlayer that the anchor point of the layer's
 * bounds rect is aligned to. Defaults to the zero point. Animatable. */

@property CGPoint position;
</code></pre>

<p>即position是CALayer的anchorPoint在其父层（superLayer）的关联位置。</p>

<h2>anchorPoint</h2>

<p>同样，在CALayer.h文件中我们可以看到:</p>

<pre><code>/* Defines the anchor point of the layer's bounds rect, as a point in
 * normalized layer coordinates - '(0, 0)' is the bottom left corner of
 * the bounds rect, '(1, 1)' is the top right corner. Defaults to
 * '(0.5, 0.5)', i.e. the center of the bounds rect. Animatable. */

 @property CGPoint anchorPoint;
</code></pre>

<p>即anchorPoint的值是相对bounds的比例值来确定的，在坐标系的左上角和右下角anchorPoint的值分别为（0，0）和（1，1），需要注意点是，文档中说的是左下角和右上角，这是在OS X上，iOS与OS X相反。anchorPoint的默认值为（0.5，0.5）即CALayer的中心位置。</p>

<p>接下来看下面两张图，只看iOS部分即可，</p>

<p><img src="/images/2014-05-10-anchor/layer_coords_anchorpoint_position_2x.png" title="ahchor1" alt="Alt ahchor1" /></p>

<p>图1</p>

<p><img src="/images/2014-05-10-anchor/anchorpoint2.jpg" title="ahchor2" alt="Alt ahchor2" /></p>

<p>图2</p>

<p>在图1中，我们可以看到，position的值是anchorPoint点在superLayer中的坐标位置。所以position点是相对于superLayer的，而anchorPoint点是相对于CALayer本身的。两者是相对不同的坐标空间的一个重合点。</p>

<p>在图2中，我们可以看到，anchorPoint的作用，其实是在CALayer做动画时的一个锚点，所有的变化是以anchorPoint为锚点进行的，相同的动画，不同的锚点，效果是全然不同的。具体的描述可以看<a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/">彻底理解position与anchorPoint</a>这篇博文。</p>

<h2>anchorPoint、position和frame之间的关系</h2>

<p>在官方的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html">Core Animation文档中</a>有这样的一句话：</p>

<blockquote><p> The bounds defines the coordinate system of the layer itself and encompasses the layer’s size on the screen. The position property defines the location of the layer relative to its parent’s coordinate system. Although layers have a frame property, that property is actually derived from the values in the bounds and position properties and is used less frequently.</p></blockquote>

<p>也就是说CALayer的frame是由CALayer的bounds属性和position属性确定的，bounds决定大小，position决定位置</p>

<pre><code> frame.origin.x = position.x - anchorPoint.x * bounds.size.width;
 frame.origin.y = position.y - anchorPoint.y * bounds.size.height;
 frame.size.width  = bounds.size.width;
 frame.size.height = bounds.size.height;
</code></pre>

<p>为此我写了一段测试代码</p>

<pre><code>CALayer *testLayer = [[CALayer alloc] init];
testLayer.frame = (CGRect){
    .origin.x = 10,
    .origin.y = 10,
    .size.width =  100,
    .size.height = 100
};
testLayer.backgroundColor = [UIColor redColor].CGColor;
[self.view.layer addSublayer:testLayer];

NSLog(@"testLayer frame = %@",NSStringFromCGRect(testLayer.frame));
NSLog(@"testLayer bounds = %@",NSStringFromCGRect(testLayer.bounds));
NSLog(@"testLayer position = %@",NSStringFromCGPoint(testLayer.position));
NSLog(@"testLayer anchorPoint = %@",NSStringFromCGPoint(testLayer.anchorPoint));

NSLog(@"\n");
NSLog(@"Change Position(20, 20)");
testLayer.position = CGPointMake(20, 20);

NSLog(@"testLayer frame = %@",NSStringFromCGRect(testLayer.frame));
NSLog(@"testLayer bounds = %@",NSStringFromCGRect(testLayer.bounds));
NSLog(@"testLayer position = %@",NSStringFromCGPoint(testLayer.position));
NSLog(@"testLayer anchorPoint = %@",NSStringFromCGPoint(testLayer.anchorPoint));


NSLog(@"\n");
NSLog(@"Change anchorPoint(0.4, 0.4)");
testLayer.anchorPoint = CGPointMake(0.4, 0.4);

NSLog(@"testLayer frame = %@",NSStringFromCGRect(testLayer.frame));
NSLog(@"testLayer bounds = %@",NSStringFromCGRect(testLayer.bounds));
NSLog(@"testLayer position = %@",NSStringFromCGPoint(testLayer.position));
NSLog(@"testLayer anchorPoint = %@",NSStringFromCGPoint(testLayer.anchorPoint))
</code></pre>

<p>其输出为：</p>

<pre><code>testLayer frame = ((10, 10), (100, 100))
testLayer bounds = ((0, 0), (100, 100))
testLayer position = (60, 60)
testLayer anchorPoint = (0.5, 0.5)

Change Position(20, 20)
testLayer frame = ((-30, -30), (100, 100))
testLayer bounds = ((0, 0), (100, 100))
testLayer position = (20, 20}
testLayer anchorPoint = (0.5, 0.5)

Change anchorPoint(0.4, 0.4)
testLayer frame = ((-20, -20), (100, 100))
testLayer bounds = ((0, 0), (100, 100))
testLayer position = (20, 20)
testLayer anchorPoint = (0.40000001, 0.40000001)
</code></pre>

<p>从中我们可以验证我们之前的公式是正确的，即frame的origin是由position和anchorPoints共同决定的，而frame的size则是由bounds决定的。</p>

<p>另外一个问题就是，单方面修改layer的position位置或者是anchorPoint，其两者互不影响，受影响的只会是frame.origin，也就是layer坐标原点相对superLayer会有所改变。</p>

<p>最后，在<a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/">彻底理解position与anchorPoint</a>这篇博文的有说到一点，</p>

<blockquote><p>Apple doc中还有一句描述是这样的：</p>

<blockquote><p>When you specify the frame of a layer, position is set relative to the anchor point. When you specify the position of the layer, bounds is set relative to the anchor point.</p></blockquote>

<p>大意是：当你设置图层的frame属性的时候，position根据锚点（anchorPoint）的值来确定，而当你设置图层的>position属性的时候，bounds会根据锚点(anchorPoint)来确定。
这段翻译的上半句根据前面的公式容易理解，后半句可能就有点令人迷惑了，当修改position时，bounds的width与>height会随之修改吗？其实,position是点，bounds是矩形，根据锚点(anchorPoint)来确定的只是它们的位置，而不>是内部属性。所以，上面这段英文这么翻译就容易理解了：</p>

<blockquote><p>当你设置图层的frame属性的时候，position点的位置（也就是position坐标）根据锚点（anchorPoint）的值来确 定，而当你设置图层的position属性的时候，bounds的位置（也就是frame的orgin坐标）会根据锚点(anchorPoint)来确定</p></blockquote></blockquote>

<h2>最后</h2>

<p>终于完成第一篇技术博客，发现确实写文章和写代码很像，对于如何提高自己的思路和条理有大帮助，应该好好把握，多写写，哈哈！</p>

<h3>参考</h3>

<ul>
<li><p><a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/">彻底理解position与anchorPoint</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html">Core Animation Programming Guide</a></p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/22/ni-hao-%21wo-de-di-%5B%3F%5D-pian-bo-ke/">你好！我的第一篇博客</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-22T12:13:48+08:00" pubdate data-updated="true">Mar 22<span>nd</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><pre><code>发现很多时候，自己有很多想法、很多想要的事，但是却总是停留在“想”上面，行动一直跟不上。
</code></pre>

<p>我一直是一个&#8221;跟风型&#8221;的人，每次看到别人身上有什么优点，而这个优点又是适合我的，我势必想尽办法复制过来为我所用，无论是大学时候听百家讲坛、看报纸、看杂志，还是毕业后坚持看书的习惯，都是我从身边的朋友、或者所崇拜的人那里复制学习而来，然后慢慢的将其变成自己的习惯。写博客，一直是很多技术大牛所极力推荐和践行的学习方法和生活方式，所以我也一直想搞一个自己的博客来记录自己的工作、学习和生活，当然最原始的动机还是因为很多大牛说，通过写技术博客可以大大提高自己的技术水平。（哈哈 想想功利性太强了哈）</p>

<p>最开始有在网易博客写了几篇技术文章，其实也不算是写，那个时候是菜鸟中的彩鸟，（显然现在也还是菜鸟）只是做了一个搬运工，把别人的写好的给搬运到自己的博客下，后来没坚持多久就没写了，主要是很不喜欢网易博客的风格，广告一堆一堆的，看了真心烦。后来，加入了一个开发群，里面的一个大牛说可以用一个叫Octopress搭建一个Github的博客，当时，那个心情跟哥伦布大哥发现新大陆的心情应该是一样的。然后，立刻到他的博客上去看他的那篇介绍文字，看完后，我得心也凉了，里面太多的技术词不懂，看的云里来雾里去，还说要有一个自己的ip地址，本来就没什么信心的我，在没有任何尝试的情况下就放弃。后面，也常看到别人发到微博上关于搭建博客的教程，大都也是收藏了，然后就没有然后（原来我真的是三分钟热度的人哦）。</p>

<p>直到最近看了<a href="http://nathanmarz.com/blog/you-should-blog-even-if-you-have-no-readers.html">You should blog even if you have no readers</a>和<a href="http://www.vaikan.com/developer-road-the-list/">如何成为一名程序员:我的道路</a>这两篇文章，重新激起了我搭建一个自己的博客的想法。我觉得这次无论如何都要成功。于是，这两天利用空闲时间，根据破船大哥的文章<a href="http://beyondvincent.com/blog/2013/08/03/108-creating-a-github-blog-using-octopress/">利用Octopress搭建一个Github博客</a>搭建了这个博客，结果发现之前所想象的困难，都是自己吓自己而已，虽然对于git和markdown都不是很了解，但是按照网上的参考资料一步一步来，很容易就能搭建好了。很多时候，并不是困难把我们吓到了，而是我们自己把自己吓倒了，就想阿甘的妈妈说的：“人生就像一盒混着各种口味的巧克力，你不吃下去，永不都不知道下一个巧克力是什么味道”（好像这句话根本不是这样的，忽略吧）</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/20/xie-zai-26sui-sheng-ri-shi/">写在26岁生日时</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/17/7yue-yue-du-qing-dan/">7月阅读清单</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/07/zhe-li-shi-jiang-nan/">这里是江南 - 记清明徽杭古道之行</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/22/wo-du-liao-shi-yao-%3Fno-dot-4-2015-03-22/">我读了什么？No.4 (2015-03-22)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/19/wo-du-liao-shi-yao-%3Fno-dot-3-2015-01-18/">我读了什么？No.3 (2015-01-18)</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 陈宏彬 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
